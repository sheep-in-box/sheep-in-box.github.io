<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【RabbitMQ】Go实现</title>
    <link href="/2024/07/24/%E3%80%90RabbitMQ%E3%80%91Go%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/07/24/%E3%80%90RabbitMQ%E3%80%91Go%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>RabbitMQ是一个消息代理，底层为队列，支持AMQP（高级消息队列协议）。</p><h2 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h2><ul><li><strong>应用解耦</strong>：生产者和消费者之间通过消息传递进行通信，而非直接调用。</li><li><strong>异步通信</strong>：消息的发送方可以在不等待响应的情况下继续执行，消息会被存储在队列中等待接收者处理，提高了系统的吞吐量。</li><li><strong>削峰填谷</strong>：在遇到瞬时的高流量情况下，消息队列作为缓冲区，防止数据过载。</li></ul><h2 id="消息队列的缺点"><a href="#消息队列的缺点" class="headerlink" title="消息队列的缺点"></a>消息队列的缺点</h2><ul><li><strong>降低系统的可用性</strong>：系统引入外部依赖越多，越容易挂掉。</li><li><strong>系统复杂度提高</strong>：需要面对各种问题，比如保证消息没有被重复消费、处理信息丢失的情况、保证消息传递的顺序性。</li><li><strong>一致性问题</strong>：多个系统处理消息可能成功可能不成功，造成数据不一致。</li></ul><h2 id="Go使用RabbitMQ"><a href="#Go使用RabbitMQ" class="headerlink" title="Go使用RabbitMQ"></a>Go使用RabbitMQ</h2><p>首先，安装rabbitmq</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">choco install rabbitmq</code></pre></div></figure><p>安装后，会自动启动服务，默认运行在本地<code>5672</code>端口，管理界面为<code>localhost:15672</code>，默认用户和密码均为guest<br><img src="/2024/07/24/%E3%80%90RabbitMQ%E3%80%91Go%E5%AE%9E%E7%8E%B0/IMG-20240724144435282.png"><br>接下来用go编写两段程序<code>send.go</code>和<code>receive.go</code>模拟消息发送方和接收方。</p><p><code>send.go</code>:</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (&quot;context&quot;&quot;log&quot;&quot;time&quot;amqp &quot;github.com&#x2F;rabbitmq&#x2F;amqp091-go&quot;)func main() &#123;&#x2F;&#x2F; 连接到RabbitMQ服务器（broker）conn, err :&#x3D; amqp.Dial(&quot;amqp:&#x2F;&#x2F;guest:guest@localhost:5672&#x2F;&quot;)if err !&#x3D; nil &#123;log.Fatalf(&quot;connection.open: %s&quot;, err)&#125;defer conn.Close()&#x2F;&#x2F; 创建channel（amqp.Channel）ch, err :&#x3D; conn.Channel()if err !&#x3D; nil &#123;log.Fatalf(&quot;channel.open: %s&quot;, err)&#125;defer ch.Close()&#x2F;&#x2F; 声明一个队列ch.QueueDeclare(&quot;hello&quot;, &#x2F;&#x2F; 队列名称，若该队列不存在则创建false,   &#x2F;&#x2F; durablefalse,   &#x2F;&#x2F; delete when unusedfalse,   &#x2F;&#x2F; exclusivefalse,   &#x2F;&#x2F; no-waitnil,     &#x2F;&#x2F; arguments)&#x2F;&#x2F; 发送消息到队列，超时时间设为2秒ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 2*time.Second)defer cancel() &#x2F;&#x2F; 带超时context的固定写法msg :&#x3D; &quot;Hello World!&quot;ch.PublishWithContext(ctx,&quot;&quot;,      &#x2F;&#x2F; exchange&quot;hello&quot;, &#x2F;&#x2F; exchange为空时，key为队列名称false,   &#x2F;&#x2F; mandatoryfalse,   &#x2F;&#x2F; immediateamqp.Publishing&#123; &#x2F;&#x2F; 消息内容ContentType: &quot;text&#x2F;plain&quot;, &#x2F;&#x2F; MIME content typeBody:        []byte(msg),&#125;,)&#125;</code></pre></div></figure><p><code>receive.go</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (&quot;log&quot;amqp &quot;github.com&#x2F;rabbitmq&#x2F;amqp091-go&quot;)func main() &#123;&#x2F;&#x2F; 连接到RabbitMQ服务器（broker）conn, err :&#x3D; amqp.Dial(&quot;amqp:&#x2F;&#x2F;guest:guest@localhost:5672&#x2F;&quot;)if err !&#x3D; nil &#123;log.Fatalf(&quot;connection.open: %s&quot;, err)&#125;defer conn.Close()&#x2F;&#x2F; 创建channel（amqp.Channel）ch, err :&#x3D; conn.Channel()if err !&#x3D; nil &#123;log.Fatalf(&quot;channel.open: %s&quot;, err)&#125;defer ch.Close()&#x2F;&#x2F; 声明一个队列，这里不需要声明队列，因为send.go已经声明过了&#x2F;&#x2F; 如果声明队列参数不一致，会报错&#x2F;&#x2F; ch.QueueDeclare(&#x2F;&#x2F; &quot;hello&quot;, &#x2F;&#x2F; 队列名称，若该队列不存在则创建&#x2F;&#x2F; false,   &#x2F;&#x2F; durable&#x2F;&#x2F; false,   &#x2F;&#x2F; delete when unused&#x2F;&#x2F; false,   &#x2F;&#x2F; exclusive&#x2F;&#x2F; false,   &#x2F;&#x2F; no-wait&#x2F;&#x2F; nil,     &#x2F;&#x2F; arguments&#x2F;&#x2F; )&#x2F;&#x2F; 接收消息，返回go语言原生channel（只读）deliverieCh, err :&#x3D; ch.Consume(&quot;hello&quot;, &#x2F;&#x2F; queue&quot;&quot;,      &#x2F;&#x2F; consumertrue,    &#x2F;&#x2F; auto-ackfalse,   &#x2F;&#x2F; exclusivefalse,   &#x2F;&#x2F; no-localfalse,   &#x2F;&#x2F; no-waitnil,     &#x2F;&#x2F; args)if err !&#x3D; nil &#123;log.Fatalf(&quot;basic.consume: %s&quot;, err)&#125;&#x2F;&#x2F; 从deliverieCh中读取消息for delivery :&#x3D; range deliverieCh &#123;log.Printf(&quot;Received a message: %s&quot;, delivery.Body)&#125;&#125;</code></pre></div></figure><p>运行<code>send.go</code>后可以在管理页面看到创建了一个队列。<br><img src="/2024/07/24/%E3%80%90RabbitMQ%E3%80%91Go%E5%AE%9E%E7%8E%B0/IMG-20240724151614453.png"></p><p>运行<code>receive.go</code>后可以看到打印出接收到的消息。程序并没有结束运行，因为<code>deliverieCh</code>并没有关闭，所以consumer进程会一直阻塞等待下一条消息的到来。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">2024&#x2F;07&#x2F;24 15:16:48 Received a message: Hello World!</code></pre></div></figure><p>回到管理页面可以看到该消息队列多了一个consumer<br><img src="/2024/07/24/%E3%80%90RabbitMQ%E3%80%91Go%E5%AE%9E%E7%8E%B0/IMG-20240724151916476.png"></p><p>按下<kbd>Ctrl</kbd>+<kbd>C</kbd>结束consumer进程，可以看到该队列下的consumer没有了（就不截图了）。</p><p>此后可以测试启动<code>receive.go</code>并反复执行<code>send.go</code>（可以把声明队列注释掉），都是可以收到消息的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go语言</tag>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go设计模式】0.面向对象设计原则</title>
    <link href="/2024/07/16/%E3%80%90Go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%910-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2024/07/16/%E3%80%90Go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%910-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>供复习使用</p><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h2 id="S-O-L-I-D"><a href="#S-O-L-I-D" class="headerlink" title="S.O.L.I.D"></a>S.O.L.I.D</h2><table><thead><tr><th>简称</th><th>全称</th><th>中文</th></tr></thead><tbody><tr><td>SRP</td><td>Single Responsibility Principle</td><td>单一职责原则</td></tr><tr><td>OCP</td><td>Open-Closed Principle</td><td>开放封闭原则</td></tr><tr><td>LSP</td><td>Liskov Substitution Principle</td><td>里氏替换原则</td></tr><tr><td>ISP</td><td>Interface Segregation Principle</td><td>接口隔离原则</td></tr><tr><td>DIP</td><td>Dependency Inversion Principle</td><td>依赖倒置原则</td></tr></tbody></table><h3 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1. 单一职责原则"></a>1. 单一职责原则</h3><blockquote><p>一个类应该只有一个引起它变化的原因。</p></blockquote><p>让一个类只负责一件事，当这个类需要做的事情过多的时候，就应该拆解这个类。<br>如果一个类承担的职责过多，相当于这些职责之间形成了紧耦合，一个职责的变化可能会削弱这个类完成其它职责的能力。</p><h3 id="2-开放封闭原则"><a href="#2-开放封闭原则" class="headerlink" title="2. 开放封闭原则"></a>2. 开放封闭原则</h3><blockquote><p>类应该对扩展开放，对修改关闭。</p></blockquote><p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改原本的代码。</p><p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p><h3 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3. 里氏替换原则"></a>3. 里氏替换原则</h3><blockquote><p>子类对象必须能够替换掉所有父类对象。</p></blockquote><p>继承是一种 “is a” 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p><p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h3><blockquote><p>不应该强迫客户依赖于它们不使用的方法。</p></blockquote><p>因此使用多个专门的接口比使用单一的总接口要好。</p><h3 id="5-依赖倒置原则"><a href="#5-依赖倒置原则" class="headerlink" title="5. 依赖倒置原则"></a>5. 依赖倒置原则</h3><blockquote><p>高层模块不应依赖于低层模块，两者都应该依赖于抽象。<br>抽象不应该依赖于细节，细节应该依赖于抽象。</p></blockquote><p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p><p>依赖于抽象意味着：</p><ul><li>任何变量都不应该持有一个指向具体类的指针或者引用；</li><li>任何类都不应该从具体类派生；</li><li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li></ul><h2 id="其他常见原则"><a href="#其他常见原则" class="headerlink" title="其他常见原则"></a>其他常见原则</h2><h3 id="1-迪米特法则"><a href="#1-迪米特法则" class="headerlink" title="1.迪米特法则"></a>1.迪米特法则</h3><p>迪米特法则又叫作最少知识原则（Least Knowledge Principle），就是说一个对象应当对其他对象有尽可能少的了解。</p><h3 id="2-合成复用原则"><a href="#2-合成复用原则" class="headerlink" title="2. 合成复用原则"></a>2. 合成复用原则</h3><p>尽量使用对象的组合&#x2F;聚合来实现代码复用，而不是通过继承。</p>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>Go语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2024/07/16/test/"/>
    <url>/2024/07/16/test/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>测试</p><p>图片显示<br><img src="/2024/07/16/test/IMG-20240716141949673.png"></p>    <div id="aplayer-YXBZSXpK" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1349927611" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/07/16/hello-world/"/>
    <url>/2024/07/16/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
